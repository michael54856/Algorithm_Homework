# 題目
題目:

計算陣列中任意三個數字相加為零的組合數

(數組中不會有重複的數字)

input:

[-1,1,2,4,8,-3]

output:

2

# 解題
以下為一種解法,測起來比維基百科上的解快許多

一開始會先取得**正數的個數**,**負數的個數**以及數列中的**最大值**和**最小值**

如果**最大值**遠大於**最小值**的話,會把**最大值**設為**最小值**乘上-2

這個目的是為了縮小界線,可過濾許多不需考慮的值,因為三個數裡面如果有一個**最大值**(已經設為**最小值**乘上-2),那就必須有2個**最小值**,和才會是0

反之如果**最小值**遠小於**最大值**的話,會把**最小值**設為**最大值**乘上-2

之後會把正數與負數分成兩個陣列儲存,並用一個很長的陣列去紀錄哪個數字有出現過(有的話把那格設為1)

之後要把正數與負數兩個陣列做排序

現在開始我們要來計算有幾組three sum,三個數的和為0有以下幾種狀況

* 正 + 負 + 0  = 0 
* 正 + 負 + 負 = 0
* 正 + 正 + 負 = 0

之後我會拿一個負數來作為標準,看能不能取得後續的兩個數字

我會從最大的負數開始下手(取絕對最小)

因為我一定需要至少一個正數,而一定會有一個正數會 >= (負數取絕對值/2),這樣才能構成和為0的狀況

所以在決定一個負數之後,我會再取得要從正數的哪裡開始判斷->**posStart**(用while找到一正數 >= (負數取絕對值/2))

算出第三個數字之後,再用**紀錄數字是否出現過的陣列**去做判斷就能得知是否為threesum

因為我們不會以比較小的數字來當第二個數字,所以沒有組合重複的問題

因為負數會慢慢變小(取絕對值變大),所需的第二個正數也要變大,所以**posStart**只會越來越大(**posStart**可以沿用,且會增長)

代表負數越小,要判斷的正數就越少,省去許多不必要的判斷

跑起來的效能比wiki上的解快100%,不開多執行緒可到**0.05s**左右

wiki上的解目前測無法突破**0.1s**

開多執行緒之後從**0.05s**進步到**0.035s**,進步幅度沒有很大




# 排名
![image](https://github.com/michael54856/Algorithm_Homework/blob/main/hw02/rank.png)

